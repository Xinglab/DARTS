# -*- coding: UTF-8 -*-

"""The wrapper script for calling Darts Rcpp model from Python.
"""

import os
from .convert_rmats import read_rmats_counts, write_darts_counts_from_rmats
from . import pretty_writter
import logging

import rpy2.robjects as ro
from rpy2.robjects.packages import importr
Darts_BHT_Rcpp = importr("Darts")

logger = logging.getLogger('Darts_BHT.bayes_infer')

def run_darts_BHT_norep(in_fn, out_fn, out_RData_fn, cutoff, rescale_meth, rho_fn, verbose, thread):
	"""Use rpy2 to call ``Darts.Darts`` from R package.

	Args:
		in_fn (str): filepath for input counts
		out_fn (str): output inference results txt
		out_RData_fn (str): output RData file for changing posterior thresholds
		cutoff (float): Cutoff of delta-PSI Posterior probability
		rescale_method (int): Rescaling method from prediction score to informative prior, 
			1:Gaussian mixture, 2:bias estimates
		rho_fn (str): filepath to prediction file, if none, then perform flat-prior analysis
		verbose (int): verbose level
		thread (int): number of threads
		
	Returns:
		0 if success

	Todo:
		- change R multi-threading code to write RData
	"""
	frame = (in_fn,
		out_fn,
		out_RData_fn,
		rescale_meth,
		cutoff,
		rho_fn,
		verbose,
		thread)
	#print(frame)

	Darts_BHT_Rcpp.Darts(in_fn=in_fn,
		out_fn=out_fn,
		out_RData_fn=out_RData_fn,
		C=cutoff,
		rescale_meth=rescale_meth,
		rho_fn=rho_fn,
		verbose=verbose,
		thread=thread)
	return 0


def run_darts_BHT_rep(in_fn, out_fn, out_RData_fn, cutoff, rescale_meth, rho_fn, estim_gVar, is_paired, pooled, verbose, thread):
	"""Use rpy2 to call ``Darts.Darts_replicate`` from R package.

	Args:
		in_fn (str): filepath for input counts
		out_fn (str): output inference results txt
		out_RData_fn (str): output RData file for changing posterior thresholds
		cutoff (float): Cutoff of delta-PSI Posterior probability
		rescale_method (int): Rescaling method from prediction score to informative prior, 
			1:Gaussian mixture, 2:bias estimates
		rho_fn (str): filepath to prediction file, if none, then perform flat-prior analysis
		estim_gVar (bool): Use prior to estimate within group variance
		is_paired (bool): if is_paired, run paired replicate model
		pooled (bool): if pooled, merge all replicates and run no-replicate model
		verbose (int): verbose level
		thread (int): number of threads
		
	Returns:
		0 if success

	Todo:
		- change R multi-threading code to write RData
	"""
	frame = (in_fn,
		out_fn,
		out_RData_fn,
		rescale_meth,
		cutoff,
		rho_fn,
		estim_gVar,
		is_paired,
		pooled,
		verbose,
		thread)
	#print(frame)

	Darts_BHT_Rcpp.Darts_replicate(in_fn=in_fn,
		out_fn=out_fn,
		out_RData_fn=out_RData_fn,
		rescale_meth=rescale_meth,
		C=cutoff,
		rho_fn=rho_fn,
		estim_groupVar_prior=estim_gVar,
		is_paired=is_paired,
		pooling=pooled,
		verbose=verbose,
		thread=thread)
	return 0


def validate_count_file(fp, replicate_model):
	"""Read through the count file and validate the input options.

	Args:
		fp (str): filepath for count file
		replicate_model (str): user-specified replicate model mode, must be in ['none', 'paired', 'unpaired'].
	
	Returns:
		(bool, str):
			has_replicates: auto-detected whether input count file has replicated RNA-seq counts;
			replicate_model: validated replicate model run mode
	"""
	has_replicates = True
	with open(fp, 'r') as f:
		firstline = True
		for line in f:
			ele = line.strip().split()
			if firstline:
				header = {ele[i]:i for i in range(len(ele))}
				if 'IJC_SAMPLE_1' in ele and 'IJC_SAMPLE_2' in ele:
					count_names = ['IJC_SAMPLE_1', 'IJC_SAMPLE_2', 'SJC_SAMPLE_1', 'SJC_SAMPLE_2']
				else:
					count_names = ['I1', 'I2', 'S1', 'S2']
				firstline = False
				continue
			this_data = [ele[header[x]].split(',') for x in count_names]
			this_data_len = [x for x in map(len, this_data)]
			if not all([x>1 for x in this_data_len]):
				has_replicates = False
			if replicate_model=="paired" and len(set(this_data_len))!=1:
				logger.info('detected un-paired data at line %s'%line)
				logger.info('changing to unpaired mode')
				replicate_model = 'unpaired'
	return has_replicates, replicate_model


def parser(args):
	"""Parser entry for BHT_wrapper. The basic workflow for this wrapper is 

		- prepare the count file;
		- call the statistical model;
		- then write a human-readible Excel file. 

	If a **Darts** count file is provided through option ``--darts-count``, the program expects a file with at least 7 columns:

		ID    I1    S1    I2    S2    inc_len    skp_len

	If an **rMATS** count file is provided through option ``--rmats-count``, the program will also require the annotation file, which
	is named "fromGTF.{eventType}.txt" generated by ``Darts_BHT rmats_count`` or standalone rMATS 
	program. 

	Whether the input count file has replicates is automatically determined in the process of 
	validating the count file, by examining there are replicated counts separaed by comma ",". 
	If the program detects an input file without replicates, the replicate-model related options will
	be ignored.

	Args:
		args: Namespace object from `Darts_BHT` script
	Returns:
		None
	"""
	is_paired = args.replicate_model == 'paired'
	pooled = args.replicate_model == 'pooled'
	event_type = args.event_type
	rescale_meth_map = {'gaussian_mixture':1, 'bias_estimates':2}
	args.rescale_method = rescale_meth_map[args.rescale_method]
	if not os.path.isdir(args.outdir):
		os.makedirs(args.outdir)
	validated_count_fp = os.path.join(args.outdir, "{}.input.txt".format(args.event_type) )

	# parsing counts file
	if args.rmats_count_fp:
		if not os.path.isfile(args.rmats_count_fp):
			raise Exception("input count file '%s' is not found"%in_fn)
		if not args.annot or not os.path.isfile(args.annot):
			raise Exception("annotation file must be specified if using rmats count")
		logger.info('Coverting rMATS count to Darts format')
		exon_dict, _ = read_rmats_counts(count_fp=args.rmats_count_fp, annot_fp=args.annot, event_type=args.event_type)
		write_darts_counts_from_rmats(exon_dict, fn=validated_count_fp)
	elif args.darts_count_fp:
		validated_count_fp = args.darts_count_fp

	logger.info('input count={}'.format(validated_count_fp))
	logger.info('output dir={}'.format(args.outdir))

	# auto-detect if has replicates
	has_replicates, args.replicate_model = validate_count_file(validated_count_fp, args.replicate_model)
	
	if not has_replicates and (args.estim_gVar or args.replicate_model!='none'):
		logger.info('detected input file has no replicates; your "replicate_model" or "estim_gVar" options will be ignored')
	if has_replicates and args.replicate_model=="none":
		args.replicate_model='unpaired'

	# call Rcpp code
	prior_suffix = 'info' if args.prior else 'flat'
	out_fn = os.path.join(args.outdir, "{}.darts_bht.{}.txt".format(args.event_type, prior_suffix))
	out_RData_fn = os.path.join(args.outdir, "{}.darts_bht.{}.RData".format(args.event_type, prior_suffix))
	args.prior = ro.NA_Integer if not args.prior else args.prior
	if has_replicates:
		logger.info('using replicate model, mode "{}"'.format( args.replicate_model ) )
		run_darts_BHT_rep(
			in_fn=validated_count_fp,
			out_fn=out_fn,
			out_RData_fn=out_RData_fn,
			cutoff=args.cutoff,
			rescale_meth=args.rescale_method,
			rho_fn=args.prior,
			estim_gVar=args.estim_gVar,
			is_paired=is_paired,
			pooled=pooled,
			verbose=args.verbose,
			thread=args.nthread
			)
	else:
		logger.info('using no-replicate model')
		run_darts_BHT_norep(
			in_fn=validated_count_fp, 
			out_fn=out_fn,
			out_RData_fn=out_RData_fn,
			cutoff=args.cutoff, 
			rescale_meth=args.rescale_method, 
			rho_fn=args.prior, 
			verbose=args.verbose, 
			thread=args.nthread)

	## add module beatify results in XLSX format by integrating annotation file
	if args.annot:
		pretty_writter.write_xlsx(out_fn, args.annot, args.event_type)
	return